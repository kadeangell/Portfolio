const R=Object.getPrototypeOf(async function(){}).constructor;function x(){}let o=x;const v=0,b=1,k=2,y=3,T=4,S=5,M=6,F=7,E=8;function w(f){switch(f){case v:return"NOT_SET";case b:return"NOTIFY_KEY";case k:return"NOTIFY_RESIZE";case y:return"NOTIFY_OPEN_FILE_BUF_COMPLETE";case T:return"NOTIFY_CLIPBOARD_WRITE_COMPLETE";case S:return"REQUEST_CMDLINE";case M:return"REQUEST_SHARED_BUF";case F:return"NOTIFY_ERROR_OUTPUT";case E:return"STATUS_NOTIFY_EVAL_FUNC_RET";default:return`Unknown command: ${f}`}}class _{constructor(e,t,r){this.worker=new Worker(e),this.worker.onmessage=this.recvMessage.bind(this),this.worker.onerror=this.recvError.bind(this),this.sharedBuffer=new Int32Array(new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT*128)),this.onMessage=t,this.onError=r,this.onOneshotMessage=new Map,this.debug=!1,this.pendingEvents=[]}terminate(){this.worker.terminate(),this.worker.onmessage=null,o("Terminated worker thread. Thank you for working hard!")}sendStartMessage(e){this.worker.postMessage(e),o("Sent start message",e)}notifyOpenFileBufComplete(e,t){this.enqueueEvent(y,t,e)}notifyClipboardWriteComplete(e,t){this.enqueueEvent(T,e,t)}notifyKeyEvent(e,t,r,n,i,s){this.enqueueEvent(b,t,r,n,i,s,e)}notifyResizeEvent(e,t){this.enqueueEvent(k,e,t)}async requestSharedBuffer(e){this.enqueueEvent(M,e);const t=await this.waitForOneshotMessage("shared-buf:response");if(t.buffer.byteLength!==e)throw new Error(`Size of shared buffer from worker ${t.buffer.byteLength} bytes mismatches to requested size ${e} bytes`);return[t.bufId,t.buffer]}notifyClipboardError(){this.notifyClipboardWriteComplete(!0,0),o("Reading clipboard failed. Notify it to worker")}async responseClipboardText(e){const t=new TextEncoder().encode(e),[r,n]=await this.requestSharedBuffer(t.byteLength+1);new Uint8Array(n).set(t),this.notifyClipboardWriteComplete(!1,r),o("Wrote clipboard",t.byteLength,"bytes text and notified to worker")}async requestCmdline(e){if(e.length===0)throw new Error("Specified command line is empty");this.enqueueEvent(S,e);const t=await this.waitForOneshotMessage("cmdline:response");if(o("Result of command",e,":",t.success),!t.success)throw Error(`Command '${e}' was invalid and not accepted by Vim`)}async notifyErrorOutput(e){const t=new TextEncoder().encode(e),[r,n]=await this.requestSharedBuffer(t.byteLength);new Uint8Array(n).set(t),this.enqueueEvent(F,r),o("Sent error message output:",e)}async notifyEvalFuncRet(e){const t=new TextEncoder().encode(e),[r,n]=await this.requestSharedBuffer(t.byteLength);new Uint8Array(n).set(t),this.enqueueEvent(E,!1,r),o("Sent return value of evaluated JS function:",e)}async notifyEvalFuncError(e,t,r){const n=`${e} for jsevalfunc(): ${t.message}: ${t.stack}`;if(r)return o("Will send error output from jsevalfunc() though the invocation was notify-only:",n),this.notifyErrorOutput(n);const i=new TextEncoder().encode("E9999: "+n),[s,a]=await this.requestSharedBuffer(i.byteLength);new Uint8Array(a).set(i),this.enqueueEvent(E,!0,s),o("Sent exception thrown by evaluated JS function:",e,t)}onEventDone(e){const t=w(e),r=this.pendingEvents.shift();if(r===void 0)throw new Error(`FATAL: Received ${t} event but event queue is empty`);if(r[0]!==e)throw new Error(`FATAL: Received ${t} event but queue says previous event was ${w(r[0])} with args ${r[1]}`);if(this.pendingEvents.length===0){o("No pending event remains after event",t);return}o("After",t,"event, still",this.pendingEvents.length,"events are pending");const[n,i]=this.pendingEvents[0];this.sendEvent(n,i)}enqueueEvent(e,...t){if(this.pendingEvents.push([e,t]),this.pendingEvents.length>1){o("Other event is being handled by worker. Pending:",w(e),t);return}this.sendEvent(e,t)}sendEvent(e,t){const r=w(e);this.debug&&Atomics.load(this.sharedBuffer,0)!==v&&console.error("INVARIANT ERROR! Status byte must be zero cleared:",r),o("Write event",r,"payload to buffer:",t);let n=0;this.sharedBuffer[n++]=e;for(const i of t)switch(typeof i){case"string":n=this.encodeStringToBuffer(i,n);break;case"number":this.sharedBuffer[n++]=i;break;case"boolean":this.sharedBuffer[n++]=+i;break;default:throw new Error(`FATAL: Invalid value for payload to worker: ${i}`)}o("Wrote",n*4,"bytes to buffer for event",r),Atomics.notify(this.sharedBuffer,0,1),o("Notified event",r,"to worker")}async waitForOneshotMessage(e){return new Promise(t=>{this.onOneshotMessage.set(e,t)})}encodeStringToBuffer(e,t){let r=t;const n=e.length;this.sharedBuffer[r++]=n;for(let i=0;i<n;++i)this.sharedBuffer[r++]=e.charCodeAt(i);return r}recvMessage(e){const t=e.data,r=this.onOneshotMessage.get(t.kind);if(r!==void 0){this.onOneshotMessage.delete(t.kind),r(t);return}this.onMessage(t)}recvError(e){o("Received an error from worker:",e);const t=`${e.message} (${e.filename}:${e.lineno}:${e.colno})`;this.onError(new Error(t))}}class A{constructor(e,t,r,n){this.canvas=r,this.worker=n,this.elemHeight=t,this.elemWidth=e;const i=window.devicePixelRatio||1;this.canvas.width=e*i,this.canvas.height=t*i,this.bounceTimerToken=null,this.onResize=this.onResize.bind(this)}onVimInit(){window.addEventListener("resize",this.onResize,{passive:!0})}onVimExit(){window.removeEventListener("resize",this.onResize)}doResize(){const e=this.canvas.getBoundingClientRect();o("Resize Vim:",e),this.elemWidth=e.width,this.elemHeight=e.height;const t=window.devicePixelRatio||1;this.canvas.width=e.width*t,this.canvas.height=e.height*t,this.worker.notifyResizeEvent(e.width,e.height)}onResize(){this.bounceTimerToken!==null&&window.clearTimeout(this.bounceTimerToken),this.bounceTimerToken=window.setTimeout(()=>{this.bounceTimerToken=null,this.doResize()},500)}}class I{constructor(e,t){this.worker=e,this.elem=t,this.onKeydown=this.onKeydown.bind(this),this.onBlur=this.onBlur.bind(this),this.onFocus=this.onFocus.bind(this),this.focus()}setFont(e,t){this.elem.style.fontFamily=e,this.elem.style.fontSize=`${t}px`}focus(){this.elem.focus()}onVimInit(){this.elem.addEventListener("keydown",this.onKeydown,{capture:!0}),this.elem.addEventListener("blur",this.onBlur),this.elem.addEventListener("focus",this.onFocus)}onVimExit(){this.elem.removeEventListener("keydown",this.onKeydown),this.elem.removeEventListener("blur",this.onBlur),this.elem.removeEventListener("focus",this.onFocus)}onKeydown(e){e.preventDefault(),e.stopPropagation(),o("onKeydown():",e,e.key,e.keyCode);let t=e.key;const r=e.ctrlKey,n=e.shiftKey,i=e.altKey,s=e.metaKey;if(t.length>1&&(t==="Unidentified"||r&&t==="Control"||n&&t==="Shift"||i&&t==="Alt"||s&&t==="Meta")){o("Ignore key input",t);return}(t==="Â¥"||!n&&t==="|"&&e.code==="IntlYen")&&(t="\\"),this.worker.notifyKeyEvent(t,e.keyCode,r,n,i,s)}onFocus(){o("onFocus()")}onBlur(e){o("onBlur():",e),e.preventDefault()}}class O{constructor(e,t,r){this.worker=e,this.canvas=t;const n=this.canvas.getContext("2d",{alpha:!1});if(n===null)throw new Error("Cannot get 2D context for <canvas>");this.ctx=n;const i=this.canvas.getBoundingClientRect(),s=window.devicePixelRatio||1;this.canvas.width=i.width*s,this.canvas.height=i.height*s,this.canvas.addEventListener("click",this.onClick.bind(this),{capture:!0,passive:!0}),this.input=new I(this.worker,r),this.resizer=new A(i.width,i.height,t,e),this.onAnimationFrame=this.onAnimationFrame.bind(this),this.queue=[],this.rafScheduled=!1,this.perf=!1,this.fgColor="",this.spColor="",this.fontName=""}onVimInit(){this.input.onVimInit(),this.resizer.onVimInit()}onVimExit(){this.input.onVimExit(),this.resizer.onVimExit()}draw(e){this.rafScheduled||(window.requestAnimationFrame(this.onAnimationFrame),this.rafScheduled=!0),this.queue.push(e)}focus(){this.input.focus()}getDomSize(){return{width:this.resizer.elemWidth,height:this.resizer.elemHeight}}setPerf(e){this.perf=e}setColorFG(e){this.fgColor=e}setColorBG(e){}setColorSP(e){this.spColor=e}setFont(e,t){this.fontName=e,this.input.setFont(e,t)}drawRect(e,t,r,n,i,s){const a=window.devicePixelRatio||1;e=Math.floor(e*a),t=Math.floor(t*a),r=Math.floor(r*a),n=Math.floor(n*a),this.ctx.fillStyle=i,s?this.ctx.fillRect(e,t,r,n):this.ctx.rect(e,t,r,n)}drawText(e,t,r,n,i,s,a,d,h,p){const l=window.devicePixelRatio||1;t=t*l,r=r*l,n=n*l,i=i*l,s=s*l;let g=`${Math.floor(t)}px ${this.fontName}`;a&&(g="bold "+g),this.ctx.font=g,this.ctx.textBaseline="bottom",this.ctx.fillStyle=this.fgColor;const m=(r-t)/2,C=Math.floor(s+r-m);for(let c=0;c<e.length;++c){const u=e[c];u!==" "&&this.ctx.fillText(u,Math.floor(i+n*c),C)}if(d){this.ctx.strokeStyle=this.fgColor,this.ctx.lineWidth=1*l,this.ctx.setLineDash([]),this.ctx.beginPath();const c=Math.floor(s+r-m-1*l);this.ctx.moveTo(Math.floor(i),c),this.ctx.lineTo(Math.floor(i+n*e.length),c),this.ctx.stroke()}else if(h){this.ctx.strokeStyle=this.spColor,this.ctx.lineWidth=1*l;const c=Math.floor(n/3);this.ctx.setLineDash([c,c]),this.ctx.beginPath();const u=Math.floor(s+r-m-1*l);this.ctx.moveTo(Math.floor(i),u),this.ctx.lineTo(Math.floor(i+n*e.length),u),this.ctx.stroke()}else if(p){this.ctx.strokeStyle=this.fgColor,this.ctx.lineWidth=1*l,this.ctx.beginPath();const c=Math.floor(s+r/2);this.ctx.moveTo(Math.floor(i),c),this.ctx.lineTo(Math.floor(i+n*e.length),c),this.ctx.stroke()}}invertRect(e,t,r,n){const i=window.devicePixelRatio||1;e=Math.floor(e*i),t=Math.floor(t*i),r=Math.floor(r*i),n=Math.floor(n*i);const s=this.ctx.getImageData(e,t,r,n),a=s.data,d=a.length;for(let h=0;h<d;++h)a[h]=255-a[h],++h,a[h]=255-a[h],++h,a[h]=255-a[h],++h;this.ctx.putImageData(s,e,t)}imageScroll(e,t,r,n,i){const s=window.devicePixelRatio||1;e=Math.floor(e*s),t=Math.floor(t*s),r=Math.floor(r*s),n=Math.floor(n*s),i=Math.floor(i*s),this.ctx.drawImage(this.canvas,e,t,n,i,e,r,n,i)}onClick(){this.input.focus()}onAnimationFrame(){o("Rendering",this.queue.length,"events on animation frame"),this.perfMark("raf");for(const[e,t]of this.queue)this.perfMark("draw"),this[e].apply(this,t),this.perfMeasure("draw",`draw:${e}`);this.queue.length=0,this.rafScheduled=!1,this.perfMeasure("raf")}perfMark(e){this.perf&&performance.mark(e)}perfMeasure(e,t){this.perf&&(performance.measure(t??e,e),performance.clearMarks(e))}}class B{constructor(e){const t=e.workerScriptPath;if(!t)throw new Error("'workerScriptPath' option is required");if(this.handleError=this.handleError.bind(this),this.worker=new _(t,this.onMessage.bind(this),this.handleError),"canvas"in e&&"input"in e)this.screen=new O(this.worker,e.canvas,e.input);else if("screen"in e)this.screen=e.screen;else throw new Error("Invalid options for VimWasm construction: "+JSON.stringify(e));this.perf=!1,this.debug=!1,this.perfMessages={},this.running=!1,this.end=!1}start(e){var t,r,n,i,s;if(this.running||this.end)throw new Error("Cannot start Vim twice");const a=e??{clipboard:navigator.clipboard!==void 0};a.debug&&(o=console.log.bind(console,"main:"),this.worker.debug=!0),this.perf=!!a.perf,this.debug=!!a.debug,this.screen.setPerf(this.perf),this.running=!0,this.perfMark("init");const{width:d,height:h}=this.screen.getDomSize(),p={kind:"start",buffer:this.worker.sharedBuffer,canvasDomWidth:d,canvasDomHeight:h,debug:this.debug,perf:this.perf,clipboard:!!a.clipboard,files:(t=a.files,t??{}),dirs:(r=a.dirs,r??[]),fetchFiles:(n=a.fetchFiles,n??{}),persistent:(i=a.persistentDirs,i??[]),cmdArgs:(s=a.cmdArgs,s??[])};this.worker.sendStartMessage(p),o("Started with drawer",this.screen)}async dropFile(e,t){if(!this.running)throw new Error("Cannot open file since Vim is not running");o("Handling to open file",e,t);const[r,n]=await this.worker.requestSharedBuffer(t.byteLength);new Uint8Array(n).set(new Uint8Array(t)),this.worker.notifyOpenFileBufComplete(e,r),o("Wrote file",e,"to",t.byteLength,"bytes buffer and notified it to worker")}async dropFiles(e){const t=new FileReader;for(const r of e){const[n,i]=await this.readFile(t,r);await this.dropFile(n,i)}}resize(e,t){this.worker.notifyResizeEvent(e,t)}sendKeydown(e,t,r){const{ctrl:n=!1,shift:i=!1,alt:s=!1,meta:a=!1}=r??{};if(e.length>1&&(e==="Unidentified"||n&&e==="Control"||i&&e==="Shift"||s&&e==="Alt"||a&&e==="Meta")){o("Ignore key input",e);return}this.worker.notifyKeyEvent(e,t,n,i,s,a)}cmdline(e){return this.worker.requestCmdline(e)}isRunning(){return this.running}focus(){this.screen.focus()}showError(e){return this.worker.notifyErrorOutput(e)}async readFile(e,t){return new Promise((r,n)=>{e.onload=(i=>{o("Read file",t.name,"from D&D:",i),r([t.name,e.result])}),e.onerror=(()=>{e.abort(),n(new Error(`Error on loading file ${t}`))}),e.readAsArrayBuffer(t)})}async evalJS(e,t){o("Evaluating JavaScript file",e,"with size",t.byteLength,"bytes");const n='"use strict";'+new TextDecoder().decode(t);try{Function(n)()}catch(i){o("Failed to evaluate",e,"with error:",i),await this.showError(`${i.message}

${i.stack}`)}}async evalFunc(e,t,r){o("Evaluating JavaScript function:",e,t);let n;try{n=new R(e)}catch(a){return this.worker.notifyEvalFuncError("Could not construct function",a,r)}let i;try{i=await n(...t)}catch(a){return this.worker.notifyEvalFuncError("Exception was thrown while evaluating function",a,r)}if(r)return o("Evaluated JavaScript result was discarded since the message was notify-only:",i,e),Promise.resolve();let s;try{s=JSON.stringify(i)}catch(a){return this.worker.notifyEvalFuncError("Could not serialize return value as JSON from function",a,!1)}return this.worker.notifyEvalFuncRet(s)}onMessage(e){if(this.perf&&e.timestamp!==void 0){const t=Date.now()-e.timestamp,r=e.kind==="draw"?`draw:${e.event[0]}`:e.kind;this.perfMessages[r]===void 0?this.perfMessages[r]=[t]:this.perfMessages[r].push(t)}switch(e.kind){case"draw":this.screen.draw(e.event),o("draw event",e.event);break;case"done":this.worker.onEventDone(e.status);break;case"evalfunc":{const t=e.argsJson===void 0?[]:JSON.parse(e.argsJson);this.evalFunc(e.body,t,e.notifyOnly).catch(this.handleError);break}case"title":this.onTitleUpdate&&(o("title was updated:",e.title),this.onTitleUpdate(e.title));break;case"read-clipboard:request":this.readClipboard?this.readClipboard().then(t=>this.worker.responseClipboardText(t)).catch(t=>{o("Cannot read clipboard:",t),this.worker.notifyClipboardError()}):(o("Cannot read clipboard because VimWasm.readClipboard is not set"),this.worker.notifyClipboardError());break;case"write-clipboard":o("Handle writing text",e.text,"to clipboard with",this.onWriteClipboard),this.onWriteClipboard&&this.onWriteClipboard(e.text);break;case"export":this.onFileExport!==void 0&&(o("Exporting file",e.path,"with size in bytes",e.contents.byteLength),this.onFileExport(e.path,e.contents));break;case"eval":this.evalJS(e.path,e.contents).catch(this.handleError);break;case"started":this.screen.onVimInit(),this.onVimInit&&this.onVimInit(),this.perfMeasure("init"),o("Vim started");break;case"exit":this.screen.onVimExit(),this.printPerfs(),this.worker.terminate(),this.onVimExit&&this.onVimExit(e.status),o("Vim exited with status",e.status),this.perf=!1,this.debug=!1,this.screen.setPerf(!1),this.running=!1,this.end=!0;break;case"error":o("Vim threw an error:",e.message),this.handleError(new Error(e.message)),this.worker.terminate();break;default:throw new Error(`Unexpected message from worker: ${JSON.stringify(e)}`)}}handleError(e){this.onError&&this.onError(e)}printPerfs(){if(this.perf){{const e=new Map;for(const i of performance.getEntries()){const s=e.get(i.name);s===void 0?e.set(i.name,[i]):s.push(i)}const t={},r={},n=[];for(const[i,s]of e){if(s.length===1&&s[0].entryType!=="measure"){n.push(s[0]);continue}console.log(`%c${i}`,"color: green; font-size: large"),console.table(s,["duration","startTime"]);const a=s.reduce((d,h)=>d+h.duration,0);t[i]=a/s.length,r[i]=a}console.log("%cTimings (ms)","color: green; font-size: large"),console.table(n,["name","entryType","startTime","duration"]),console.log("%cAmount: Perf Mark Durations (ms)","color: green; font-size: large"),console.table(r),console.log("%cAverage: Perf Mark Durations (ms)","color: green; font-size: large"),console.table(t),performance.clearMarks(),performance.clearMeasures()}{const e={};for(const t of Object.keys(this.perfMessages)){const r=this.perfMessages[t],n=r.reduce((i,s)=>i+s,0);e[t]=n/r.length}console.log("%cAverage: Inter-thread Messages Duration (ms)","color: green; font-size: large"),console.table(e),this.perfMessages={}}}}perfMark(e){this.perf&&performance.mark(e)}perfMeasure(e){this.perf&&(performance.measure(e,e),performance.clearMarks(e))}}export{I as InputHandler,A as ResizeHandler,O as ScreenCanvas,B as VimWasm,_ as VimWorker};
